"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const typeParser_1 = require("../../parser/typeParser");
const generation_1 = require("./generation");
class FakeEvmType extends typeParser_1.EvmType {
}
describe("Ethers generation edge cases", () => {
    const emptyContract = {
        name: "TestContract",
        constantFunctions: [],
        constants: [],
        functions: [],
        events: [],
        constructor: { inputs: [], payable: false },
    };
    it("should throw on invalid function input type", () => {
        const contract = Object.assign({}, emptyContract, { constantFunctions: [
                {
                    name: "testFunction",
                    inputs: [
                        {
                            name: "testInput",
                            type: new FakeEvmType(),
                        },
                    ],
                    outputs: [],
                },
            ] });
        chai_1.expect(() => generation_1.codegenContractTypings(contract)).to.throw("Unrecognized type FakeEvmType");
    });
    it("should throw on invalid function output type", () => {
        const contract = Object.assign({}, emptyContract, { constantFunctions: [
                {
                    name: "testFunction",
                    inputs: [],
                    outputs: [
                        {
                            name: "testOutput",
                            type: new FakeEvmType(),
                        },
                    ],
                },
            ] });
        chai_1.expect(() => generation_1.codegenContractTypings(contract)).to.throw("Unrecognized type FakeEvmType");
    });
    it("should generate simple factory when no bytecode available", () => {
        chai_1.expect(generation_1.codegenContractFactory(emptyContract, "abi", "")).to.match(/export class TestContractFactory \{/);
    });
});
