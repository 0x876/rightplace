"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typeParser_1 = require("../../parser/typeParser");
function codegenContractTypings(contract) {
    const template = `
  import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
  import { Listener, Provider } from 'ethers/providers';
  import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
  import { TransactionOverrides, TypedEventDescription, TypedFunctionDescription } from ".";

  interface ${contract.name}Interface extends Interface {
    functions: {
      ${contract.functions.map(generateInterfaceFunctionDescription).join("\n")}
    };

    events: {
      ${contract.events.map(generateInterfaceEventDescription).join("\n")}
    };
  }

  export class ${contract.name} extends Contract {
    connect(signerOrProvider: Signer | Provider | string): ${contract.name};
    attach(addressOrName: string): ${contract.name};
    deployed(): Promise<${contract.name}>;

    on(event: EventFilter | string, listener: Listener): ${contract.name};
    once(event: EventFilter | string, listener: Listener): ${contract.name};
    addListener(eventName: EventFilter | string, listener: Listener): ${contract.name};
    removeAllListeners(eventName: EventFilter | string): ${contract.name};
    removeListener(eventName: any, listener: Listener): ${contract.name};

    interface: ${contract.name}Interface;

    functions: {
      ${contract.constantFunctions.map(generateConstantFunction).join("\n")}
      ${contract.functions.map(generateFunction).join("\n")}
      ${contract.constants.map(generateConstant).join("\n")}
    };

    filters: {
      ${contract.events.map(generateEvents).join("\n")}
    };

    estimate: {
      ${contract.functions.map(generateEstimateFunction).join("\n")}
    };
  }`;
    return template;
}
exports.codegenContractTypings = codegenContractTypings;
function codegenContractFactory(contract, abi, bytecode) {
    const constructorArgs = contract.constructor
        ? generateInputTypes(contract.constructor.inputs)
        : "";
    const constructorArgNames = contract.constructor
        ? generateParamNames(contract.constructor.inputs)
        : "";
    if (!bytecode)
        return codegenAbstractContractFactory(contract, abi);
    // tsc with noUnusedLocals would complain about unused imports
    const ethersUtilsImports = [];
    if (constructorArgs.match(/\WArrayish(\W|$)/))
        ethersUtilsImports.push("Arrayish");
    if (constructorArgs.match(/\WBigNumberish(\W|$)/))
        ethersUtilsImports.push("BigNumberish");
    const ethersUtilsImportLine = ethersUtilsImports.length > 0
        ? `import { ${ethersUtilsImports.join(", ")} } from "ethers/utils";`
        : "";
    return `
  import { Contract, ContractFactory, Signer } from "ethers";
  import { Provider } from "ethers/providers";
  import { UnsignedTransaction } from "ethers/utils/transaction";
  ${ethersUtilsImportLine}

  import { ${contract.name} } from "./${contract.name}";

  export class ${contract.name}Factory extends ContractFactory {
    constructor(signer?: Signer) {
      super(_abi, _bytecode, signer);
    }
    deploy(${constructorArgs}): Promise<${contract.name}> {
      return super.deploy(${constructorArgNames}) as Promise<${contract.name}>;
    }
    getDeployTransaction(${constructorArgs}): UnsignedTransaction {
      return super.getDeployTransaction(${constructorArgNames});
    };
    attach(address: string): ${contract.name} {
      return super.attach(address) as ${contract.name};
    }
    connect(signer: Signer): ${contract.name}Factory {
      return super.connect(signer) as ${contract.name}Factory;
    }
    static connect(address: string, signerOrProvider: Signer | Provider): ${contract.name} {
      return new Contract(address, _abi, signerOrProvider) as ${contract.name};
    }
  }

  const _abi = ${JSON.stringify(abi, null, 2)};

  const _bytecode = "${bytecode}";
  `;
}
exports.codegenContractFactory = codegenContractFactory;
function codegenAbstractContractFactory(contract, abi) {
    return `
  import { Contract, Signer } from "ethers";
  import { Provider } from "ethers/providers";

  import { ${contract.name} } from "./${contract.name}";

  export class ${contract.name}Factory {
    static connect(address: string, signerOrProvider: Signer | Provider): ${contract.name} {
      return new Contract(address, _abi, signerOrProvider) as ${contract.name};
    }
  }

  const _abi = ${JSON.stringify(abi, null, 2)};
  `;
}
exports.codegenAbstractContractFactory = codegenAbstractContractFactory;
function generateConstantFunction(fn) {
    return `
  ${fn.name}(${generateInputTypes(fn.inputs)}): Promise<${generateOutputTypes(fn.outputs)}>;
`;
}
function generateFunction(fn) {
    return `
  ${fn.name}(${generateInputTypes(fn.inputs)}overrides?: TransactionOverrides): Promise<ContractTransaction>;
`;
}
function generateEstimateFunction(fn) {
    return `
  ${fn.name}(${generateInputTypes(fn.inputs)}): Promise<BigNumber>;
`;
}
function generateInterfaceFunctionDescription(fn) {
    return `
  ${fn.name}: TypedFunctionDescription<{ encode(${generateParamArrayNames(fn.inputs)}: ${generateParamArrayTypes(fn.inputs)}): string; }>;
`;
}
function generateConstant(fn) {
    return `${fn.name}(): Promise<${generateOutputType(fn.output)}>;`;
}
function generateInputTypes(input) {
    if (input.length === 0) {
        return "";
    }
    return (input
        .map((input, index) => `${input.name || `arg${index}`}: ${generateInputType(input.type)}`)
        .join(", ") + ", ");
}
function generateOutputTypes(outputs) {
    if (outputs.length === 1) {
        return generateOutputType(outputs[0].type);
    }
    else {
        return `{ 
      ${outputs.map(t => t.name && `${t.name}: ${generateOutputType(t.type)}, `).join("")}
      ${outputs.map((t, i) => `${i}: ${generateOutputType(t.type)}`).join(", ")}
      }`;
    }
}
function generateParamArrayTypes(params) {
    return `[${params.map(param => generateInputType(param.type)).join(", ")}]`;
}
function generateParamNames(params) {
    return `${params.map(param => param.name).join(", ")}`;
}
function generateParamArrayNames(params) {
    return `[${generateParamNames(params)}]`;
}
function generateEvents(event) {
    return `
  ${event.name}(${generateEventTypes(event.inputs)}): EventFilter;
`;
}
function generateInterfaceEventDescription(event) {
    return `
  ${event.name}: TypedEventDescription<{ encodeTopics(${generateParamArrayNames(event.inputs)}: ${generateEventTopicTypes(event.inputs)}): string[]; }>;
`;
}
function generateEventTopicTypes(eventArgs) {
    return `[${eventArgs.map(generateEventArgType).join(", ")}]`;
}
function generateEventTypes(eventArgs) {
    if (eventArgs.length === 0) {
        return "";
    }
    return (eventArgs
        .map(arg => {
        return `${arg.name}: ${generateEventArgType(arg)}`;
    })
        .join(", ") + ", ");
}
function generateEventArgType(eventArg) {
    return eventArg.isIndexed ? `${generateInputType(eventArg.type)} | null` : "null";
}
// https://docs.ethers.io/ethers.js/html/api-contract.html#types
function generateInputType(evmType) {
    switch (evmType.constructor) {
        case typeParser_1.IntegerType:
            return "BigNumberish";
        case typeParser_1.UnsignedIntegerType:
            return "BigNumberish";
        case typeParser_1.AddressType:
            return "string";
        case typeParser_1.BytesType:
        case typeParser_1.DynamicBytesType:
            return "Arrayish";
        case typeParser_1.ArrayType:
            return `(${generateInputType(evmType.itemType)})[]`;
        case typeParser_1.BooleanType:
            return "boolean";
        case typeParser_1.StringType:
            return "string";
        case typeParser_1.TupleType:
            return generateTupleType(evmType, generateInputType);
        default:
            throw new Error(`Unrecognized type ${evmType.constructor.name}`);
    }
}
function generateOutputType(evmType) {
    switch (evmType.constructor) {
        case typeParser_1.IntegerType:
            return evmType.bits <= 48 ? "number" : "BigNumber";
        case typeParser_1.UnsignedIntegerType:
            return evmType.bits <= 48 ? "number" : "BigNumber";
        case typeParser_1.AddressType:
            return "string";
        case typeParser_1.VoidType:
            return "void";
        case typeParser_1.BytesType:
        case typeParser_1.DynamicBytesType:
            return "string";
        case typeParser_1.ArrayType:
            return `(${generateOutputType(evmType.itemType)})[]`;
        case typeParser_1.BooleanType:
            return "boolean";
        case typeParser_1.StringType:
            return "string";
        case typeParser_1.TupleType:
            return generateTupleType(evmType, generateOutputType);
        default:
            throw new Error(`Unrecognized type ${evmType.constructor.name}`);
    }
}
function generateTupleType(tuple, generator) {
    return ("{" +
        tuple.components
            .map(component => `${component.name}: ${generator(component.type)}`)
            .join(", ") +
        "}");
}
