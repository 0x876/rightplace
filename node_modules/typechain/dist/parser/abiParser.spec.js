"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const errors_1 = require("../utils/errors");
const abiParser_1 = require("./abiParser");
const typeParser_1 = require("./typeParser");
describe("extractAbi", () => {
    it("should throw error on not JSON ABI", () => {
        const inputJson = `abc`;
        chai_1.expect(() => abiParser_1.extractAbi(inputJson)).to.throw(errors_1.MalformedAbiError, "Not a json");
    });
    it("should throw error on malformed ABI", () => {
        const inputJson = `{ "someProps": "abc" }`;
        chai_1.expect(() => abiParser_1.extractAbi(inputJson)).to.throw(errors_1.MalformedAbiError, "Not a valid ABI");
    });
    it("should work with simple abi", () => {
        const inputJson = `[{ "name": "piece" }]`;
        chai_1.expect(abiParser_1.extractAbi(inputJson)).to.be.deep.eq([{ name: "piece" }]);
    });
    it("should work with nested abi (truffle style)", () => {
        const inputJson = `{ "abi": [{ "name": "piece" }] }`;
        chai_1.expect(abiParser_1.extractAbi(inputJson)).to.be.deep.eq([{ name: "piece" }]);
    });
});
describe("extractBytecode", () => {
    const sampleBytecode = "1234abcd";
    const resultBytecode = abiParser_1.ensure0xPrefix(sampleBytecode);
    it("should return bytecode for bare bytecode string", () => {
        chai_1.expect(abiParser_1.extractBytecode(sampleBytecode)).to.eq(resultBytecode);
    });
    it("should return bytecode for bare bytecode with 0x prefix", () => {
        chai_1.expect(abiParser_1.extractBytecode(resultBytecode)).to.eq(resultBytecode);
    });
    it("should return undefined for non-bytecode non-json input", () => {
        chai_1.expect(abiParser_1.extractBytecode("surely-not-bytecode")).to.be.undefined;
    });
    it("should return undefined for simple abi without bytecode", () => {
        chai_1.expect(abiParser_1.extractBytecode(`[{ "name": "piece" }]`)).to.be.undefined;
    });
    it("should return undefined for nested abi without bytecode", () => {
        chai_1.expect(abiParser_1.extractBytecode(`{ "abi": [{ "name": "piece" }] }`)).to.be.undefined;
    });
    it("should return bytecode from nested abi (truffle style)", () => {
        chai_1.expect(abiParser_1.extractBytecode(`{ "bytecode": "${sampleBytecode}" }`)).to.eq(resultBytecode);
    });
    it("should return bytecode from nested abi (ethers style)", () => {
        const inputJson = `{ "evm": { "bytecode": { "object": "${sampleBytecode}" }}}`;
        chai_1.expect(abiParser_1.extractBytecode(inputJson)).to.eq(resultBytecode);
    });
    it("should return undefined when nested abi bytecode is malformed", () => {
        chai_1.expect(abiParser_1.extractBytecode(`{ "bytecode": "surely-not-bytecode" }`)).to.be.undefined;
    });
});
describe("ensure0xPrefix", () => {
    it("should prepend 0x when it's missing", () => {
        chai_1.expect(abiParser_1.ensure0xPrefix("1234")).to.eq("0x1234");
    });
    it("should return string unchanged when it has 0x prefix", () => {
        chai_1.expect(abiParser_1.ensure0xPrefix("0x1234")).to.eq("0x1234");
    });
});
describe("parseEvent", () => {
    it("should work", () => {
        const expectedEvent = {
            anonymous: false,
            inputs: [
                { indexed: true, name: "_from", type: "address" },
                { indexed: false, name: "_value", type: "uint256" },
            ],
            name: "Deposit",
            type: "event",
        };
        const parsedEvent = abiParser_1.parseEvent(expectedEvent);
        chai_1.expect(parsedEvent).to.be.deep.eq({
            name: "Deposit",
            inputs: [
                { name: "_from", isIndexed: true, type: new typeParser_1.AddressType() },
                { name: "_value", isIndexed: false, type: new typeParser_1.UnsignedIntegerType(256) },
            ],
        });
    });
});
